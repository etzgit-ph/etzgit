# etzgit

etzgit is a small monorepo that demonstrates a secure, testable autonomous-agent flow implemented with a NestJS backend and a set of shared utility packages. The project focuses on guarded edit workflows (safe git operations, test-run rollback, PR creation) and robust LLM output parsing for producing deterministic patch proposals.

This README explains how to develop, test, and run the project locally and how to contribute safely.

## Contents
- apps/api ‚Äî NestJS application that exposes agent orchestration and services (LLM integration, Git client, GitHub PR creation).
- packages/config ‚Äî shared TypeScript configuration used by workspace packages.
- packages/* ‚Äî shared helper packages (types, constants, utils).
- docs/ ‚Äî documentation and architecture decision records (ADRs).

## Quick start (local)

Prerequisites
- Node.js (recommended 18+)
- pnpm (the repo is a pnpm workspace)
- Git (for branch/PR workflow)

Install dependencies

```bash
pnpm install
```

# ü§ñ Autonomous Code Agent (ACA) Monorepo

The Autonomous Code Agent (ACA) is a highly secure, self-modifying system designed to autonomously perform code upgrades, refactoring, and dependency management within its own repository. It operates on a Human-in-the-Loop (HIL) governance model: every autonomous change is proposed as a Pull Request (PR) and must pass a rigorous, multi-stage CI/CD validation pipeline before human review.

This monorepo follows DevSecOps and Secure Software Development Lifecycle (SSDLC) principles. Security is integrated into every layer, from local development to production simulation.

## üõ°Ô∏è Core architecture & zero-cost security model

All technologies used are free, open-source, or provide a robust free tier. The system enforces a Zero-Trust policy toward code generated by LLMs.

Component | Technology | Free / OSS Rationale | Security Principle
---|---:|---|---
Monorepo | pnpm | Open-source package manager | Standardized toolchain and dependency management
Backend API | NestJS (TypeScript) | Open-source, enterprise-grade framework | Orchestrates the autonomous loop with restricted execution endpoints
Data Validation | Zod | Open-source schema validation | Enforces strict runtime validation of LLM outputs
Code Execution | Secure Git Client (custom) | In-repo service | Enforces path restrictions and mandatory test-before-commit with rollback
Deployment Target | Docker Compose | Open-source container tooling | Self-contained local production simulation
CI/CD | GitHub Actions | Generous free tier for OSS | Automated, auditable integration and delivery
Security Scanning | Snyk (Free) + Trivy | Free/OSS scanners | Mandatory vulnerability gates for code and container images
Observability | Winston / OpenTelemetry | Open-source | Structured logging for audit trails and incident analysis

## üöÄ Getting started (local development)

Prefer developing inside a secure, containerized workspace (e.g., GitHub Codespaces) or a local machine with Docker.

1) Prerequisites

- Git
- Node.js (LTS, recommended 18+)
- pnpm
- Docker & Docker Compose

2) Install workspace dependencies

```bash
pnpm install
```

3) Configure environment variables

Create `.env.local` in `apps/api/` (use `.env.example` as a template). Important variables:

Variable | Description
---|---
API_SECRET_KEY | Secret token used to authorize the privileged `/run-agent` endpoint
GITHUB_TOKEN | Personal access token (repo scope) used to create branches and PRs
OPENAI_API_KEY | LLM service API key (or equivalent provider credentials)
DATABASE_URL | PostgreSQL connection string for local DB

4) Run the full stack

Start services with Docker Compose (API, Postgres, Redis):

```bash
# Start API, DB, and Redis
docker compose up -d

# Start the frontend dashboard (run from repo root)
pnpm --filter ./apps/web dev
```

Local endpoints and protections

Component | Local endpoint | Protection
---|---|---
API Backend | http://localhost:3000 | Rate-limited and authorization-guarded
Web Dashboard | http://localhost:3001 | Read-only audit and status UI
PostgreSQL | Docker network only | Not exposed publicly

## üß™ Validation and quality gates

All changes must pass the checks enforced by Husky locally and by GitHub Actions in CI.

Command | Description | Purpose
---|---|---
pnpm -w eslint --ext .ts,.tsx | Lint and format across the monorepo | Code consistency and style
pnpm -w test | Run unit and integration tests | Correctness and behavioral guarantees
pnpm -w test --filter ./apps/api --coverage | API unit tests with coverage | Enforces coverage thresholds
pnpm -w test:e2e | End-to-end tests (Playwright) | Full-stack, external posture and security features
pnpm audit | Dependency vulnerability scan | Detects known vulnerabilities

CI gates include static analysis (Snyk/Trivy placeholders), lint, tests, and coverage enforcement.

## üõ†Ô∏è Continuous integration & deployment

Workflows are defined in `.github/workflows/`:

- `ci.yml` ‚Äî mandatory quality gate: lint, tests, coverage, and security scans
- `staging.yml` ‚Äî ephemeral environment for running E2E against a provisioned service (placeholder Terraform)
- `production.yml` ‚Äî manual human-triggered deployment

Note: the current CI files in this repository include placeholders for Snyk/Trivy and provisioning steps. They should be extended with real scanning and provisioning commands when integrating with external services.

## Security patterns and safe operations

- Protected paths: critical files are marked as protected; the executor refuses automatic edits to these paths.
- Test-before-commit: proposed changes are run against the test-suite. Failures trigger an automatic rollback.
- PR-based approval: all successful proposals are pushed to a branch and a PR is created for human review.

## üóÇÔ∏è Implementation prompts & alignment

## LLM demo endpoint (local testing)

The repository includes a guarded demo endpoint `POST /llm/demo` that calls the LLM service in dry-run mode and returns proposed patches.

Security: requests must include the header `x-agent-secret-key` with the value set in `AGENT_RUN_SECRET` in `apps/api/.env.local`.

Example curl (local):

```bash
# set the secret in your env or .env.local
export AGENT_RUN_SECRET=secret

curl -X POST http://localhost:3000/llm/demo \
	-H "Content-Type: application/json" \
	-H "x-agent-secret-key: $AGENT_RUN_SECRET" \
	-d '{"filePath":"README.md","currentContent":"Old","goal":"Improve"}'
```

CLI helper:

```bash
# call the local endpoint (uses $AGENT_RUN_SECRET from env)
node ./tools/llm-cli.js http://localhost:3000/llm/demo

# or provide a JSON payload file
node ./tools/llm-cli.js http://localhost:3000/llm/demo ./payload.json
```


This repository includes a living checklist of implementation prompts in `docs/implementation-prompts.md`. The file contains numbered, phased prompts (001-090+) describing the desired architecture, governance, and implementation steps for ACA.

Current alignment summary (high-level):

- Foundation & governance (Prompts 001-030): Mostly present. Key artifacts exist (pnpm workspace, CONTRIBUTING, SECURITY, ADRs placeholders). Some items remain as placeholders or require CI secrets (Husky/lint-staged is referenced in root `package.json`, `.devcontainer` and strict shared `tsconfig` may need completion).
- Shared packages & constants (Prompts 031-060): Core packages exist (`packages/shared-types`, `packages/exceptions` are present in the repo; I added `packages/security-constants` and `packages/ci-utils`). Some schema and DTO work (Zod schemas, full shared-types exports) are still to be implemented.
- App modules & services (Prompts 061-090): `apps/api` is scaffolded and contains key controllers and modules. I added an `.env.example` and CI/workflow placeholders. Many of the detailed service implementations (Git client hardening, LLM parsing with Zod, executor rollback hooks, Octokit PR wiring) are described in `docs/implementation-prompts.md` but implemented only as skeletons/placeholders in the codebase ‚Äî this is intentional to keep changes low-risk.

What is placeholder vs implemented:

- Placeholders (need integration / secrets / infra): Snyk/Trivy scanning in CI, Terraform provisioning in `infra/terraform`, production Dockerfile build checks, and concrete Octokit/OAuth flows.
- Implemented (or added as scaffolding): Docker Compose files, GitHub workflow skeletons, `packages/security-constants`, `packages/ci-utils`, `apps/api/.env.example`, and the rewritten README.

How to use the prompts file

1. Read `docs/implementation-prompts.md` and pick a prompt ID to implement.
2. Follow the 'Implementation_Details' section in the prompt and update code. When adding runtime secrets or external tools, update CI workflows and add required repository secrets.
3. Mark the prompt as implemented by adding a short note in the prompt file or creating an ADR in `docs/adr/` describing the change.

If you'd like, I can start implementing a specific prompt (for example, wire Snyk into `ci.yml`, implement Zod schemas in `packages/shared-types`, or add the `apps/api/Dockerfile` multi-stage build). Tell me which prompt ID to prioritize and I'll implement it and run the relevant tests.

## Contributing

1. Create a feature branch from `main`.
2. Implement changes and add unit tests under `apps/api/src` or package tests.
3. Run local checks: `pnpm install && pnpm -w tsc --noEmit && pnpm -w test`.
4. Push the branch and open a PR. CI must pass and reviewers must approve before merge.

See `CONTRIBUTING.md` for more details on governance and safe contribution practices.

## License

This project is provided under the MIT License. See `LICENSE` for details.

